class Cadenza::Parser

rule
  target:
    : document
    | /* none */ { result = nil }
    ;

  primary_expression:
    : IDENTIFIER { result = VariableNode.new(val[0].value) }
    | INTEGER    { result = ConstantNode.new(val[0].value) }
    | REAL       { result = ConstantNode.new(val[0].value) }
    | STRING     { result = ConstantNode.new(val[0].value) }
    | '(' additive_expression ')'  { result = val[1] }
    ;

  multiplicative_expression:
    : primary_expression
    | multiplicative_expression '*' primary_expression { result = ArithmeticNode.new(val[0], "*", val[2]) }
    | multiplicative_expression '/' primary_expression { result = ArithmeticNode.new(val[0], "/", val[2]) }
    ;

  additive_expression:
    : multiplicative_expression
    | additive_expression '+' multiplicative_expression { result = ArithmeticNode.new(val[0], "+", val[2]) }
    | additive_expression '-' multiplicative_expression { result = ArithmeticNode.new(val[0], "-", val[2]) }
    ;

  parameter_list:
    : additive_expression                     { result = [val[0]] }
    | parameter_list ',' additive_expression  { result = val[0].push(val[2]) }
    ;

  filter:
    : IDENTIFIER                    { result = FilterNode.new(val[0].value) }
    | IDENTIFIER ':' parameter_list { result = FilterNode.new(val[0].value, val[1]) }
    ;

  filter_list:
    : filter { result = [val[0]] }
    | filter_list '|' filter { result = val[0].push(val[2]) }
    ;

  inject_statement:
    : VAR_OPEN additive_expression VAR_CLOSE { result = InjectNode.new(val[1]) }
    | VAR_OPEN additive_expression '|' filter_list VAR_CLOSE { result = InjectNode.new(val[1], val[3]) }
    ;

  document:
    : inject_statement { @document.children.push(val[0]) }
    ;

---- header ----
# parser.rb : generated by racc
  
---- inner ----
attr_reader :lexer

def initialize(options={})
  @lexer = options.fetch(:lexer, Cadenza::Lexer.new)

  raise "Lexers passed to the parser must define next_token" unless @lexer.respond_to?(:next_token)

  raise "Lexers passed to the parser must define source=" unless @lexer.respond_to?(:source=)
end

def parse(source)
  @lexer.source = source
  @document = DocumentNode.new
  do_parse
  @document
end

def next_token
  @lexer.next_token
end